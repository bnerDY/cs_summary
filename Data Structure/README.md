# BigO cheat sheet
http://bigocheatsheet.com/

#KMP 算法
http://www.cnblogs.com/yjiyjige/p/3263858.html

# 图


# 树

树（Tree）是n（n≥0）个有限数据元素的集合。当n＝0 时，称这棵树为空树。在一棵非空树T 中：

1. 有一个特殊的数据元素称为树的根结点，根结点没有前驱结点。
2. 除根结点之外的其余数据元素被分成m（m>0）个互不相交的集合T1，T2，…，Tm，其中每一个集合Ti（1≤i≤m）本身又是一棵树。树T1，T2，…，Tm 为这个根结点的子树（subtree）。

树具有以下特点：

1. 每个节点有零个或多个子节点。
2. 每个非根节点只有一个父节点。
3. 没有父节点的节点称为根节点。

相关术语（结点、孩子结点等术语忽略）：

* 祖先结点: 从根到该结点的所经分支上的所有结点子孙结点：以某结点为根的子树中任一结点都称为该结点的子孙；
* 结点层：规定树的根结点的层数为1，其余结点的层数等于它的双亲结点的层数加1；
* 结点的`度`：结点子树的个数。


［[二叉树与森林的转换](http://www.nowcoder.com/questionTerminal/fe30dbe0dfb1498183e832dcba5ed908)］

参考：[数据结构之树](http://c.biancheng.net/cpp/u/shuju7/)

## 二叉树

二叉树是`每个节点最多有两个子树`的树结构。二叉树的每个结点至多只有二棵子树，二叉树的子树有左右之分，次序不能颠倒。

图论中二叉树的定义如下：二叉树是一个连通无环图，并且每一个顶点的度不大于3。有根二叉树还要满足根结点的度不大于2。

二叉树的一些不是那么明显的性质：

1. 对任何一棵二叉树T，度为2的结点数为m，则叶子结点数为：m＋1。
2. 给定N个节点，能构成h(N)种不同的二叉树，其中h(N)为`卡特兰数`的第N项。h(n)=C(2*n，n)/(n+1)。

几种常用的二叉树：

* 满二叉树：一棵深度为k，且有2^k - 1个节点的二叉树称为；
* 完全二叉树：深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时。
* 二叉堆：它一棵完全的二叉树，二叉堆一般分为两种：最大堆和最小堆。

    * 最大（小）堆中的最大（小）元素值出现在根结点（堆顶）；
    * 堆中每个父节点的元素值都大（小）于等于其孩子结点（如果存在）。
* 二叉排序树：是一棵空树，或者是具有下列性质的二叉树：

     * 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
     * 若右子树不空，则右子树上所有结点的值均大于它的根结点的值；
     * 左、右子树也分别为二叉排序树；
     * 没有键值相等的节点。
* 平衡二叉树（AVL树）：它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

参考：  
[轻松搞定面试中的二叉树题目](http://blog.csdn.net/luckyxiaoqiang/article/details/7518888)  
[卡特兰数](https://zh.wikipedia.org/wiki/卡塔兰数)

## 树与二叉树的转换

如果设定一定规则，就可用二叉树结构表示树，这样对树的操作实现就可以借助二叉树存储，利用二叉树上的操作来实现。

`树转换为二叉树`：将一棵树转换为二叉树的方法是：

* 树中所有相邻兄弟之间加一条连线。
* 对树中的每个结点，只保留它与第一个孩子结点之间的连线，删去它与其它孩子结点之间的连线。
* 以树的根结点为轴心，将整棵树顺时针转动一定的角度，使之结构层次分明。

![][11]

二叉树转换为树或森林的过程如下：

* 若某结点是其双亲的左孩子，则把该结点的右孩子、右孩子的右孩子……都与该结点的双亲结点用线连起来；
* 删去原二叉树中所有的双亲结点与右孩子结点的连线；
* 整理由（1）、（2）两步所得到的树或森林，使之结构层次分明。

![][12]

参考：[树、森林与二叉树的转换](http://c.biancheng.net/cpp/html/987.html)

# 红黑树

红黑树是一种自平衡二叉查找树。它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用。在C++ STL中，很多部分(目前包括set, multiset, map, multimap)应用了红黑树的变体(SGI STL中的红黑树有一些变化，这些修改提供了更好的性能，以及对set操作的支持)。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(log n)时间内做查找，插入和删除等操作。

红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。

红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高.

## 红黑树的性质

红黑树，顾名思义，通过红黑两种颜色域保证树的高度近似平衡。它的每个结点是一个五元组：color（颜色），key（数据），left（左孩子），right（右孩子）和p（父结点）。
红黑树的定义也是它的性质，有以下五条：

1. 结点是红色或黑色
2. 根是黑色
3. 所有叶子都是黑色（叶子是NIL结点）
4. 如果一个结点是红的，则它的两个儿子都是黑的
5. 从任一结点到其叶子的所有简单路径都包含相同数目的黑色结点。

![][1]

这五个性质强制了红黑树的关键性质: **从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。**性质4暗示着任何一个简单路径上不能有两个毗连的红色结点，这样，最短的可能路径全是黑色结点，最长的可能路径有交替的红色和黑色结点。同时根据性质5知道：所有最长的路径都有相同数目的黑色结点，这就表明了没有路径能多于任何其他路径的两倍长。

## 基本操作

因为红黑树也是二叉查找树，因此红黑树上的查找操作与普通二叉查找树上的查找操作相同。

然而，红黑树上的插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量(O(log n))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)。虽然插入和删除很复杂，但操作时间仍可以保持为 O(log n) 次。

### 插入操作

首先以二叉查找树的方法增加结点并标记它为红色。（如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑结点，这个是很难调整的。但是设为红色结点后，可能会导致出现两个连续红色结点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整。）下面要进行什么操作取决于其他临近结点的颜色。

设要插入的结点为N，N的父结点标为P，N的叔父结点标为U，N的祖父结点标为G。（即P和U是G的孩子结点）。图中展示的任何颜色要么是由它所处情形这些所作的假定，要么是假定所暗含（imply）的。

`情形1`. **新结点N位于树的根上，没有父结点**。（插入树的第一个结点）

在这种情形下，我们把它重绘为黑色以满足性质2。因为它在每个路径上对黑结点数目增加一，性质5符合。

`情形2`. **父结点P是黑色**，则整棵树不必调整便是红黑树。新结点是红色的，所以性质4没有失效。尽管新结点N有两个黑色叶子子结点；但由于新结点N是红色，通过它的每个子结点的路径就都有同通过它所取代的黑色的叶子的路径同样数目的黑色结点，性质5也未受到威胁。

`情形3`. **父结点P是红色（祖父结点G一定为黑色），叔父结点U也是红色**。则我们可以将P，U重绘为黑色并重绘祖父结点G为红色（用来保持性质5）。但是，红色的祖父结点G可能是根结点，这就违反了性质2，也有可能祖父结点G的父结点是红色的，这就违反了性质4。为了解决这个问题，在祖父结点G上递归调整颜色。

![][2]

（此时新插入结点N做为P的左子结点或右子结点都属于情形3，这里仅显示N做为P左子的情形）

`情形4`. **父结点P是红色（祖父结点G一定为黑色），叔父结点U是黑色或缺少，并且新结点N是左孩子**。则针对祖父结点G进行一次右旋转；在旋转产生的树中，以前的父结点P现在是新结点N和以前的祖父结点G的父结点。以前的祖父结点G是黑色，切换以前的父结点P和祖父结点G的颜色，结果的树满足性质4，5。

![][3]

（此时P为祖父结点G的左子结点或右子结点都属于情形4，这里仅显示P为G左子的情形）

`情形5`. **父结点P是红色（祖父结点G一定为黑色），叔父结点U是黑色或缺少，并且新结点N是右孩子**。则针对父结点P进行一次左旋转调换新结点N和P的角色，接着按情形4进行处理。

![][4]

## 删除操作

首先以二叉查找树的方法找到要删除的结点，如果需要删除的结点有两个非叶子的孩子结点，那么问题可以转化成删除的结点最多有一个非叶子的孩子结点。（对于二叉查找树，在删除带有两个非叶子儿子的结点的时候，要么找到它的前驱（左子树中的最大元素）、要么找到后继（右子树中的最小元素），并把它的值拷贝到要删除的结点中。接着删除前驱（或后继），注意前驱（后继）的非叶子孩子结点数必定少于2。因为拷贝前驱（后继）值时不违反任何性质，所以上面的问题转化成立）。

如果被删除的结点没有非叶子的孩子，那么直接删除，然后用一个叶子结点代替它的位置，不用作其它树调整。

下面只讨论删除的结点只有一个非叶子结点孩子的情况。如果**删除的是一个红色节点**，它的父亲和孩子一定是黑色的，所以我们可以简单的用它的黑色儿子替换它，并不会破坏红黑树的性质。另一种简单情况是在**被删除节点是黑色而它的儿子是红色的时候**。我们重绘它的儿子为黑色，则曾经通过它的所有路径将通过它的黑色儿子，这样可以继续保持性质5。

需要进一步讨论的是在要**删除的节点和它的儿子二者都是黑色的时候**，这是一种复杂的情况。我们首先把要删除的节点替换为它的儿子。出于方便，称呼这个儿子为N（在新的位置上），称呼它的兄弟（它父亲的另一个儿子）为S。在下面的示意图中，我们使用P称呼N的父亲，S<sub>L</sub> 称呼S的左儿子，S<sub>R</sub> 称呼S的右儿子。

`情形1`. **N是新的根**。在这种情形下，从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。

`情形2`. **S是红色（N的父亲P是黑色）**。在N的父亲P上做左旋转，把 S 转换成N的祖父，接着对调新的父亲P和新的祖父S的颜色。完成这两个操作后，N有了一个黑色的兄弟和一个红色的父亲（它的新兄弟是黑色因为它是红色S的一个儿子），接下去按情形4、情形5或情形6来处理。

![][5]

`情形3`. **S和S的儿子都是黑色，N的父亲P是黑色**。简单的重绘S为红色。结果是通过S的所有路径，都少了一个黑色节点，因为删除N的初始的父亲使通过N的所有路径少了一个黑色节点。但是，通过P的所有路径现在比不通过P的路径少了一个黑色节点，所以仍然违反性质5。要修正这个问题，我们要从情形1开始，在P上做重新平衡处理。

![][6]

`情形4`. **S和S的儿子都是黑色，N的父亲P是红色**。简单的交换N的兄弟和父亲的颜色。这不影响不通过N的路径的黑色节点的数目，但是它在通过N的路径上对黑色节点数目增加了一，添补了在这些路径上删除的黑色节点。

![][7]

`情形5`. **S是黑色，S的左儿子是红色，S的右儿子是黑色**。在S上做右旋转，这样S的左儿子成为S的父亲和N的新兄弟。接着交换S和它的新父亲的颜色，所有路径仍有同样数目的黑色节点，但是现在N有了一个黑色兄弟，它的右儿子是红色的，所以我们进入了情形4。

![][8]

`情形6`. **S是黑色，S的右儿子是红色**。在N的父亲上做左旋转，这样S成为N的父亲（P）和S的右儿子的父亲。我们接着交换N的父亲和S的颜色，并使S的右儿子为黑色。子树在它的根上的仍是同样的颜色，所以性质3没有被违反。但是，N现在增加了一个黑色祖先：要么N的父亲变成黑色，要么它是黑色而S被增加为一个黑色祖父。

![][9]

## 参考

[数据结构之红黑树](http://dongxicheng.org/structure/red-black-tree/)  
[Wiki：红黑树](https://zh.wikipedia.org/wiki/红黑树)


# Hashtable

哈希表就是一种以键-值(key-indexed) 存储数据的结构，我们只要输入待查找的值即 key，即可查找到其对应的值。

哈希查找第一步就是使用哈希函数将键映射成索引，这种映射函数就是`哈希函数`。如果我们有一个保存0-M数组，那么我们就需要一个能够将任意键转换为该数组范围内的索引（0~M-1）的哈希函数。哈希函数需要易于计算并且能够均匀分布所有键。一个好的哈希函数必须在理论上非常的快、稳定并且是可确定的。

哈希函数通常是由他们产生哈希值的方法来定义的，有两种主要的方法：

1. 基于加法和乘法的散列：这种方式是通过遍历数据中的元素然后每次对某个初始值进行加操作，其中加的值和这个数据的一个元素相关。通常这对某个元素值的计算要乘以一个素数。
2. 基于移位的散列：和加法散列类似，基于移位的散列也要利用字符串数据中的每个元素，但是和加法不同的是，后者更多的而是进行位的移位操作。通常是结合了左移和右移，移的位数的也是一个素数。每个移位过程的结果只是增加了一些积累计算，最后移位的结果作为最终结果。

DEK：Knuth在《编程的艺术 第三卷》的第六章排序和搜索中给出一个 Hash 函数如下：

    long DEKHash(string str)
    {     long hash = str.length();
        for(int i = 0; i < str.length(); i++)
        {
            hash = ((hash << 5) ^ (hash >> 27)) ^ str[i];
        }
        return hash;
    } 
对于两个或者多个键具有相同索引值的情况，如何有效避免hash结果值的碰撞？

* `拉链法`：将大小为M的数组的每一个元素指向一个条链表，链表中的每一个节点都存储散列值为该索引的键值对。
* `开放寻址法`：使用大小为M的数组来保存N个键值对，其中M>N，使用数组中的空位解决碰撞冲突。其中最简单的是线性探测法，当碰撞发生时即一个键的散列值被另外一个键占用时，直接检查散列表中的下一个位置即将索引值加1。

为什么一般hashtable的桶数会取一个`素数`？

首先来说假如关键字是随机分布的，那么无所谓一定要模质数。但在实际中往往关键字有某种规律，例如大量的等差数列，那么公差和模数不互质的时候发生碰撞的概率会变大，而用质数就可以很大程度上回避这个问题。

参考： [浅谈算法和数据结构: 十一 哈希表](http://www.cnblogs.com/yangecnu/p/Introduce-Hashtable.html)

# bitmap

位图（bitmap）是一种非常常用的结构，在索引，数据压缩等方面有广泛应用，能同时使存储空间和速度最优化。例如可用一个10位长的字符串来表示一个所有元素都小于10的简单的非负整数集合，可以用 `01110100100` 表示集合 {1,2,4,5,8} ，对应位置数字存在标记为1，否则标记为0。

C 语言位图实现如下：

![][10]

主要程序如下：

    #define SHIFT 5  
    #define MASK 0x1F  

    //set 设置所在的bit位为1  
    //clr 初始化所有的bit位为0  
    //test 测试所在的bit为是否为1  
    
    set(int i) {
        a[i>>SHIFT] |=  (1<<(i & MASK)); }  
    clr(int i) {
        a[i>>SHIFT] &= ~(1<<(i & MASK)); }  
    test(int i){
        return a[i>>SHIFT] & (1<<(i & MASK)); } 

字节位置=数据/32 (采用位运算即右移5位)  
位位置=数据%32   (采用位运算即跟0X1F进行与操作)。

特定适用场合：

1. 对10亿个不重复的整数进行排序。
2. 找出10亿个数字中重复的数字。

如果用普通的排序算法，数据放进内存就需要 ( 10^9 * 4)/( 2^30 ) = 3.7G。改用 Bitmap 的话，一个数字占一位，一共需要 3.7/32 ＝ 0.1 G 内存。

参考：[详解bitmap算法](http://www.wjxfpf.com/2015/10/300404.html)


[10]: http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_1.jpg
[11]: http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_2.jpg
[12]: http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_3.jpg

[1]: http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_RB_1.png
[2]: http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_RB_2.png
[3]: http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_RB_3.png
[4]: http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_RB_4.png
[5]: http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_RB_5.png
[6]: http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_RB_6.png
[7]: http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_RB_7.png
[8]: http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_RB_8.png
[9]: http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_RB_9.png


